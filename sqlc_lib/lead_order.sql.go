// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: lead_order.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const checkLeadHasOrder = `-- name: CheckLeadHasOrder :one
select count(*) from lead_order
where lead_id = $1
`

// check is there any order or all order get deleted
func (q *Queries) CheckLeadHasOrder(ctx context.Context, leadID uuid.NullUUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkLeadHasOrder, leadID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLeadOrder = `-- name: CreateLeadOrder :one
insert into lead_order (
    lead_id,
    device_type,
    device_model,
    device_price,
    device_name
) values (
    $1,$2,$3,$4,$5
) returning id, lead_id, device_type, device_model, device_name, device_price, created_at, updated_at
`

type CreateLeadOrderParams struct {
	LeadID      uuid.NullUUID  `json:"lead_id"`
	DeviceType  sql.NullString `json:"device_type"`
	DeviceModel sql.NullString `json:"device_model"`
	DevicePrice sql.NullInt32  `json:"device_price"`
	DeviceName  sql.NullString `json:"device_name"`
}

func (q *Queries) CreateLeadOrder(ctx context.Context, arg CreateLeadOrderParams) (LeadOrder, error) {
	row := q.db.QueryRowContext(ctx, createLeadOrder,
		arg.LeadID,
		arg.DeviceType,
		arg.DeviceModel,
		arg.DevicePrice,
		arg.DeviceName,
	)
	var i LeadOrder
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.DeviceType,
		&i.DeviceModel,
		&i.DeviceName,
		&i.DevicePrice,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLeadOrder = `-- name: DeleteLeadOrder :execresult
delete from lead_order
where id = $1 and lead_id = $2
`

type DeleteLeadOrderParams struct {
	ID     uuid.UUID     `json:"id"`
	LeadID uuid.NullUUID `json:"lead_id"`
}

// delete a order by order id
func (q *Queries) DeleteLeadOrder(ctx context.Context, arg DeleteLeadOrderParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteLeadOrder, arg.ID, arg.LeadID)
}

const fetchLeadOrderByOrderId = `-- name: FetchLeadOrderByOrderId :one
select id, lead_id, device_type, device_model, device_name, device_price, created_at, updated_at from lead_order
where id = $1
limit 1
`

// fetch lead order by order id
func (q *Queries) FetchLeadOrderByOrderId(ctx context.Context, id uuid.UUID) (LeadOrder, error) {
	row := q.db.QueryRowContext(ctx, fetchLeadOrderByOrderId, id)
	var i LeadOrder
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.DeviceType,
		&i.DeviceModel,
		&i.DeviceName,
		&i.DevicePrice,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const fetchOrdersByLeadId = `-- name: FetchOrdersByLeadId :many
select id, lead_id, device_type, device_model, device_name, device_price, created_at, updated_at from lead_order
where lead_id = $1
order by created_at desc
`

// fetch all order by lead id
func (q *Queries) FetchOrdersByLeadId(ctx context.Context, leadID uuid.NullUUID) ([]LeadOrder, error) {
	rows, err := q.db.QueryContext(ctx, fetchOrdersByLeadId, leadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LeadOrder{}
	for rows.Next() {
		var i LeadOrder
		if err := rows.Scan(
			&i.ID,
			&i.LeadID,
			&i.DeviceType,
			&i.DeviceModel,
			&i.DeviceName,
			&i.DevicePrice,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLeadOrder = `-- name: UpdateLeadOrder :one
update lead_order
set device_type = $3,
device_model = $4,
device_price = $5,
updated_at = CURRENT_TIMESTAMP
where id = $1 and lead_id = $2
returning id, lead_id, device_type, device_model, device_name, device_price, created_at, updated_at
`

type UpdateLeadOrderParams struct {
	ID          uuid.UUID      `json:"id"`
	LeadID      uuid.NullUUID  `json:"lead_id"`
	DeviceType  sql.NullString `json:"device_type"`
	DeviceModel sql.NullString `json:"device_model"`
	DevicePrice sql.NullInt32  `json:"device_price"`
}

// update a specific order
func (q *Queries) UpdateLeadOrder(ctx context.Context, arg UpdateLeadOrderParams) (LeadOrder, error) {
	row := q.db.QueryRowContext(ctx, updateLeadOrder,
		arg.ID,
		arg.LeadID,
		arg.DeviceType,
		arg.DeviceModel,
		arg.DevicePrice,
	)
	var i LeadOrder
	err := row.Scan(
		&i.ID,
		&i.LeadID,
		&i.DeviceType,
		&i.DeviceModel,
		&i.DeviceName,
		&i.DevicePrice,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
