// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: sales_lead.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createNewLead = `-- name: CreateNewLead :one
insert into sale_leads (
    lead_by,
    referal_name,
    referal_contact,
    status,
    quatation_count
) values (
    $1,$2,$3,$4,$5
) returning id, lead_by, referal_name, referal_contact, status, quatation_count, created_at, updated_at
`

type CreateNewLeadParams struct {
	LeadBy         uuid.UUID     `json:"lead_by"`
	ReferalName    string        `json:"referal_name"`
	ReferalContact string        `json:"referal_contact"`
	Status         string        `json:"status"`
	QuatationCount sql.NullInt32 `json:"quatation_count"`
}

func (q *Queries) CreateNewLead(ctx context.Context, arg CreateNewLeadParams) (SaleLeads, error) {
	row := q.db.QueryRowContext(ctx, createNewLead,
		arg.LeadBy,
		arg.ReferalName,
		arg.ReferalContact,
		arg.Status,
		arg.QuatationCount,
	)
	var i SaleLeads
	err := row.Scan(
		&i.ID,
		&i.LeadBy,
		&i.ReferalName,
		&i.ReferalContact,
		&i.Status,
		&i.QuatationCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const fetchAllLeads = `-- name: FetchAllLeads :many
select id, lead_by, referal_name, referal_contact, status, quatation_count, created_at, updated_at from sale_leads
order by created_at desc
limit $1
offset $2
`

type FetchAllLeadsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// fetch all leads
func (q *Queries) FetchAllLeads(ctx context.Context, arg FetchAllLeadsParams) ([]SaleLeads, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllLeads, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SaleLeads{}
	for rows.Next() {
		var i SaleLeads
		if err := rows.Scan(
			&i.ID,
			&i.LeadBy,
			&i.ReferalName,
			&i.ReferalContact,
			&i.Status,
			&i.QuatationCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchLeadByLeadId = `-- name: FetchLeadByLeadId :one
select id, lead_by, referal_name, referal_contact, status, quatation_count, created_at, updated_at from sale_leads
where id = $1
limit 1
`

// fetch lead by id
func (q *Queries) FetchLeadByLeadId(ctx context.Context, id uuid.UUID) (SaleLeads, error) {
	row := q.db.QueryRowContext(ctx, fetchLeadByLeadId, id)
	var i SaleLeads
	err := row.Scan(
		&i.ID,
		&i.LeadBy,
		&i.ReferalName,
		&i.ReferalContact,
		&i.Status,
		&i.QuatationCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const increaeQuatationCount = `-- name: IncreaeQuatationCount :execrows
update sale_leads
set quatation_count = quatation_count + 1,
updated_at = CURRENT_TIMESTAMP
where id = $1
`

// increase a quatation count
func (q *Queries) IncreaeQuatationCount(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, increaeQuatationCount, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateSaleLeadReferal = `-- name: UpdateSaleLeadReferal :one
update sale_leads
set referal_name = $2,
referal_contact = $3,
updated_at = CURRENT_TIMESTAMP
where id = $1
returning id, lead_by, referal_name, referal_contact, status, quatation_count, created_at, updated_at
`

type UpdateSaleLeadReferalParams struct {
	ID             uuid.UUID `json:"id"`
	ReferalName    string    `json:"referal_name"`
	ReferalContact string    `json:"referal_contact"`
}

// update a lead
func (q *Queries) UpdateSaleLeadReferal(ctx context.Context, arg UpdateSaleLeadReferalParams) (SaleLeads, error) {
	row := q.db.QueryRowContext(ctx, updateSaleLeadReferal, arg.ID, arg.ReferalName, arg.ReferalContact)
	var i SaleLeads
	err := row.Scan(
		&i.ID,
		&i.LeadBy,
		&i.ReferalName,
		&i.ReferalContact,
		&i.Status,
		&i.QuatationCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
