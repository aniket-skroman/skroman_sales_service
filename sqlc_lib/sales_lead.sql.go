// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: sales_lead.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const countOfLeads = `-- name: CountOfLeads :one
select count(*) from sale_leads
`

func (q *Queries) CountOfLeads(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOfLeads)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createNewLead = `-- name: CreateNewLead :one
insert into sale_leads (
    lead_by,
    referal_name,
    referal_contact,
    status,
    quatation_count
) values (
    $1,$2,$3,$4,$5
) returning id, lead_by, referal_name, referal_contact, status, quatation_count, created_at, updated_at, is_lead_info, is_order_info
`

type CreateNewLeadParams struct {
	LeadBy         uuid.UUID     `json:"lead_by"`
	ReferalName    string        `json:"referal_name"`
	ReferalContact string        `json:"referal_contact"`
	Status         string        `json:"status"`
	QuatationCount sql.NullInt32 `json:"quatation_count"`
}

func (q *Queries) CreateNewLead(ctx context.Context, arg CreateNewLeadParams) (SaleLeads, error) {
	row := q.db.QueryRowContext(ctx, createNewLead,
		arg.LeadBy,
		arg.ReferalName,
		arg.ReferalContact,
		arg.Status,
		arg.QuatationCount,
	)
	var i SaleLeads
	err := row.Scan(
		&i.ID,
		&i.LeadBy,
		&i.ReferalName,
		&i.ReferalContact,
		&i.Status,
		&i.QuatationCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLeadInfo,
		&i.IsOrderInfo,
	)
	return i, err
}

const fetchAllLeads = `-- name: FetchAllLeads :many
select sl.id as lead_id,
sl.lead_by as lead_by, sl.referal_name as referal_name,
sl.referal_contact as referal_contact, sl.status as status,
sl.created_at as lead_created_at, sl.updated_at as lead_updated_at,
sl.is_lead_info as is_lead_info, sl.is_order_info as is_order_info,
sl.quatation_count as quatation_count, li.id as lead_info_id,
li.name as name, li.email as email, li.contact as contact,
li.address_line_1 as address_line_1, li.city as city, li.state as state,
li.lead_type as lead_type, li.created_at as lead_info_created_at,
li.updated_at as lead_info_updated_at
from sale_leads as sl
left join lead_info as li 
on sl.id = li.lead_id
order by sl.created_at desc
limit $1
offset $2
`

type FetchAllLeadsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type FetchAllLeadsRow struct {
	LeadID            uuid.UUID      `json:"lead_id"`
	LeadBy            uuid.UUID      `json:"lead_by"`
	ReferalName       string         `json:"referal_name"`
	ReferalContact    string         `json:"referal_contact"`
	Status            string         `json:"status"`
	LeadCreatedAt     time.Time      `json:"lead_created_at"`
	LeadUpdatedAt     time.Time      `json:"lead_updated_at"`
	IsLeadInfo        sql.NullBool   `json:"is_lead_info"`
	IsOrderInfo       sql.NullBool   `json:"is_order_info"`
	QuatationCount    sql.NullInt32  `json:"quatation_count"`
	LeadInfoID        uuid.NullUUID  `json:"lead_info_id"`
	Name              sql.NullString `json:"name"`
	Email             sql.NullString `json:"email"`
	Contact           sql.NullString `json:"contact"`
	AddressLine1      sql.NullString `json:"address_line_1"`
	City              sql.NullString `json:"city"`
	State             sql.NullString `json:"state"`
	LeadType          sql.NullString `json:"lead_type"`
	LeadInfoCreatedAt sql.NullTime   `json:"lead_info_created_at"`
	LeadInfoUpdatedAt sql.NullTime   `json:"lead_info_updated_at"`
}

// fetch all leads
func (q *Queries) FetchAllLeads(ctx context.Context, arg FetchAllLeadsParams) ([]FetchAllLeadsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllLeads, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchAllLeadsRow{}
	for rows.Next() {
		var i FetchAllLeadsRow
		if err := rows.Scan(
			&i.LeadID,
			&i.LeadBy,
			&i.ReferalName,
			&i.ReferalContact,
			&i.Status,
			&i.LeadCreatedAt,
			&i.LeadUpdatedAt,
			&i.IsLeadInfo,
			&i.IsOrderInfo,
			&i.QuatationCount,
			&i.LeadInfoID,
			&i.Name,
			&i.Email,
			&i.Contact,
			&i.AddressLine1,
			&i.City,
			&i.State,
			&i.LeadType,
			&i.LeadInfoCreatedAt,
			&i.LeadInfoUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchLeadByLeadId = `-- name: FetchLeadByLeadId :one
select sl.id as lead_id,
sl.lead_by as lead_by, sl.referal_name as referal_name,
sl.referal_contact as referal_contact, sl.status as status,
sl.created_at as lead_created_at, sl.updated_at as lead_updated_at,
sl.is_lead_info as is_lead_info, sl.is_order_info as is_order_info,
sl.quatation_count as quatation_count, li.id as lead_info_id,
li.name as name, li.email as email, li.contact as contact,
li.address_line_1 as address_line_1, li.city as city, li.state as state,
li.lead_type as lead_type, li.created_at as lead_info_created_at,
li.updated_at as lead_info_updated_at
from sale_leads as sl
left join lead_info as li 
on sl.id = li.lead_id
where sl.id = $1
limit 1
`

type FetchLeadByLeadIdRow struct {
	LeadID            uuid.UUID      `json:"lead_id"`
	LeadBy            uuid.UUID      `json:"lead_by"`
	ReferalName       string         `json:"referal_name"`
	ReferalContact    string         `json:"referal_contact"`
	Status            string         `json:"status"`
	LeadCreatedAt     time.Time      `json:"lead_created_at"`
	LeadUpdatedAt     time.Time      `json:"lead_updated_at"`
	IsLeadInfo        sql.NullBool   `json:"is_lead_info"`
	IsOrderInfo       sql.NullBool   `json:"is_order_info"`
	QuatationCount    sql.NullInt32  `json:"quatation_count"`
	LeadInfoID        uuid.NullUUID  `json:"lead_info_id"`
	Name              sql.NullString `json:"name"`
	Email             sql.NullString `json:"email"`
	Contact           sql.NullString `json:"contact"`
	AddressLine1      sql.NullString `json:"address_line_1"`
	City              sql.NullString `json:"city"`
	State             sql.NullString `json:"state"`
	LeadType          sql.NullString `json:"lead_type"`
	LeadInfoCreatedAt sql.NullTime   `json:"lead_info_created_at"`
	LeadInfoUpdatedAt sql.NullTime   `json:"lead_info_updated_at"`
}

// fetch lead by id
func (q *Queries) FetchLeadByLeadId(ctx context.Context, id uuid.UUID) (FetchLeadByLeadIdRow, error) {
	row := q.db.QueryRowContext(ctx, fetchLeadByLeadId, id)
	var i FetchLeadByLeadIdRow
	err := row.Scan(
		&i.LeadID,
		&i.LeadBy,
		&i.ReferalName,
		&i.ReferalContact,
		&i.Status,
		&i.LeadCreatedAt,
		&i.LeadUpdatedAt,
		&i.IsLeadInfo,
		&i.IsOrderInfo,
		&i.QuatationCount,
		&i.LeadInfoID,
		&i.Name,
		&i.Email,
		&i.Contact,
		&i.AddressLine1,
		&i.City,
		&i.State,
		&i.LeadType,
		&i.LeadInfoCreatedAt,
		&i.LeadInfoUpdatedAt,
	)
	return i, err
}

const fetchLeadCountByMonth = `-- name: FetchLeadCountByMonth :many
with lm as 
(
SELECT
	to_char(d, 'Month') as n_month
FROM
    GENERATE_SERIES(
        now(),
        now() - interval '12 months',
        interval '-1 months'
    ) AS d
)


select  l.n_month as month,
count(distinct sl.id)
from lm as l
left join sale_leads as sl 
on l.n_month = to_char(sl.created_at, 'Month')
group by to_char(sl.created_at, 'Month'),l.n_month
order by l.n_month desc
`

type FetchLeadCountByMonthRow struct {
	Month string `json:"month"`
	Count int64  `json:"count"`
}

func (q *Queries) FetchLeadCountByMonth(ctx context.Context) ([]FetchLeadCountByMonthRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchLeadCountByMonth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchLeadCountByMonthRow{}
	for rows.Next() {
		var i FetchLeadCountByMonthRow
		if err := rows.Scan(&i.Month, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchLeadCounts = `-- name: FetchLeadCounts :one
select (select count(*) from sale_leads where status = 'INIT') as init_leads,
(select count(*) from sale_leads where status = 'PLACED') as placed_leads,
(select count(*) from sale_leads where status = 'CANCLED') as cancled_leads,
(select count(*) from order_quatation where date_trunc('month', created_at) = date_trunc('month', current_date)) as total_quotations,
count(*) as total_leads     
from sale_leads
`

type FetchLeadCountsRow struct {
	InitLeads       int64 `json:"init_leads"`
	PlacedLeads     int64 `json:"placed_leads"`
	CancledLeads    int64 `json:"cancled_leads"`
	TotalQuotations int64 `json:"total_quotations"`
	TotalLeads      int64 `json:"total_leads"`
}

// counts for landing page
func (q *Queries) FetchLeadCounts(ctx context.Context) (FetchLeadCountsRow, error) {
	row := q.db.QueryRowContext(ctx, fetchLeadCounts)
	var i FetchLeadCountsRow
	err := row.Scan(
		&i.InitLeads,
		&i.PlacedLeads,
		&i.CancledLeads,
		&i.TotalQuotations,
		&i.TotalLeads,
	)
	return i, err
}

const fetchLeadsByStatus = `-- name: FetchLeadsByStatus :many
select sl.id as lead_id,
sl.lead_by as lead_by, sl.referal_name as referal_name,
sl.referal_contact as referal_contact, sl.status as status,
sl.created_at as lead_created_at, sl.updated_at as lead_updated_at,
sl.is_lead_info as is_lead_info, sl.is_order_info as is_order_info,
sl.quatation_count as quatation_count, li.id as lead_info_id,
li.name as name, li.email as email, li.contact as contact,
li.address_line_1 as address_line_1, li.city as city, li.state as state,
li.lead_type as lead_type, li.created_at as lead_info_created_at,
li.updated_at as lead_info_updated_at
from sale_leads as sl
left join lead_info as li 
on sl.id = li.lead_id
where sl.status = $1
order by sl.created_at desc
limit $2
offset $3
`

type FetchLeadsByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type FetchLeadsByStatusRow struct {
	LeadID            uuid.UUID      `json:"lead_id"`
	LeadBy            uuid.UUID      `json:"lead_by"`
	ReferalName       string         `json:"referal_name"`
	ReferalContact    string         `json:"referal_contact"`
	Status            string         `json:"status"`
	LeadCreatedAt     time.Time      `json:"lead_created_at"`
	LeadUpdatedAt     time.Time      `json:"lead_updated_at"`
	IsLeadInfo        sql.NullBool   `json:"is_lead_info"`
	IsOrderInfo       sql.NullBool   `json:"is_order_info"`
	QuatationCount    sql.NullInt32  `json:"quatation_count"`
	LeadInfoID        uuid.NullUUID  `json:"lead_info_id"`
	Name              sql.NullString `json:"name"`
	Email             sql.NullString `json:"email"`
	Contact           sql.NullString `json:"contact"`
	AddressLine1      sql.NullString `json:"address_line_1"`
	City              sql.NullString `json:"city"`
	State             sql.NullString `json:"state"`
	LeadType          sql.NullString `json:"lead_type"`
	LeadInfoCreatedAt sql.NullTime   `json:"lead_info_created_at"`
	LeadInfoUpdatedAt sql.NullTime   `json:"lead_info_updated_at"`
}

// lead by status
func (q *Queries) FetchLeadsByStatus(ctx context.Context, arg FetchLeadsByStatusParams) ([]FetchLeadsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchLeadsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchLeadsByStatusRow{}
	for rows.Next() {
		var i FetchLeadsByStatusRow
		if err := rows.Scan(
			&i.LeadID,
			&i.LeadBy,
			&i.ReferalName,
			&i.ReferalContact,
			&i.Status,
			&i.LeadCreatedAt,
			&i.LeadUpdatedAt,
			&i.IsLeadInfo,
			&i.IsOrderInfo,
			&i.QuatationCount,
			&i.LeadInfoID,
			&i.Name,
			&i.Email,
			&i.Contact,
			&i.AddressLine1,
			&i.City,
			&i.State,
			&i.LeadType,
			&i.LeadInfoCreatedAt,
			&i.LeadInfoUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const increaeQuatationCount = `-- name: IncreaeQuatationCount :execrows
update sale_leads
set quatation_count = quatation_count + 1,
updated_at = CURRENT_TIMESTAMP
where id = $1
`

// increase a quatation count
func (q *Queries) IncreaeQuatationCount(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, increaeQuatationCount, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const pGCountByLeadStatus = `-- name: PGCountByLeadStatus :one
select count(*) from sale_leads
where status = $1
`

// lead count by status
func (q *Queries) PGCountByLeadStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRowContext(ctx, pGCountByLeadStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateIsLeadInfo = `-- name: UpdateIsLeadInfo :one
update sale_leads
set is_lead_info = $2
where id = $1
returning id, lead_by, referal_name, referal_contact, status, quatation_count, created_at, updated_at, is_lead_info, is_order_info
`

type UpdateIsLeadInfoParams struct {
	ID         uuid.UUID    `json:"id"`
	IsLeadInfo sql.NullBool `json:"is_lead_info"`
}

// make a flags true or false for info or orde
func (q *Queries) UpdateIsLeadInfo(ctx context.Context, arg UpdateIsLeadInfoParams) (SaleLeads, error) {
	row := q.db.QueryRowContext(ctx, updateIsLeadInfo, arg.ID, arg.IsLeadInfo)
	var i SaleLeads
	err := row.Scan(
		&i.ID,
		&i.LeadBy,
		&i.ReferalName,
		&i.ReferalContact,
		&i.Status,
		&i.QuatationCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLeadInfo,
		&i.IsOrderInfo,
	)
	return i, err
}

const updateIsLeadOrder = `-- name: UpdateIsLeadOrder :one
update sale_leads
set is_order_info = $2
where id = $1
returning id, lead_by, referal_name, referal_contact, status, quatation_count, created_at, updated_at, is_lead_info, is_order_info
`

type UpdateIsLeadOrderParams struct {
	ID          uuid.UUID    `json:"id"`
	IsOrderInfo sql.NullBool `json:"is_order_info"`
}

func (q *Queries) UpdateIsLeadOrder(ctx context.Context, arg UpdateIsLeadOrderParams) (SaleLeads, error) {
	row := q.db.QueryRowContext(ctx, updateIsLeadOrder, arg.ID, arg.IsOrderInfo)
	var i SaleLeads
	err := row.Scan(
		&i.ID,
		&i.LeadBy,
		&i.ReferalName,
		&i.ReferalContact,
		&i.Status,
		&i.QuatationCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLeadInfo,
		&i.IsOrderInfo,
	)
	return i, err
}

const updateSaleLeadReferal = `-- name: UpdateSaleLeadReferal :one
update sale_leads
set referal_name = $2,
referal_contact = $3,
updated_at = CURRENT_TIMESTAMP
where id = $1
returning id, lead_by, referal_name, referal_contact, status, quatation_count, created_at, updated_at, is_lead_info, is_order_info
`

type UpdateSaleLeadReferalParams struct {
	ID             uuid.UUID `json:"id"`
	ReferalName    string    `json:"referal_name"`
	ReferalContact string    `json:"referal_contact"`
}

// update a lead
func (q *Queries) UpdateSaleLeadReferal(ctx context.Context, arg UpdateSaleLeadReferalParams) (SaleLeads, error) {
	row := q.db.QueryRowContext(ctx, updateSaleLeadReferal, arg.ID, arg.ReferalName, arg.ReferalContact)
	var i SaleLeads
	err := row.Scan(
		&i.ID,
		&i.LeadBy,
		&i.ReferalName,
		&i.ReferalContact,
		&i.Status,
		&i.QuatationCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsLeadInfo,
		&i.IsOrderInfo,
	)
	return i, err
}
